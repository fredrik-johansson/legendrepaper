#include "arb_hypgeom.h"
#include "flint/profiler.h"

#define TIMEIT_PRINT1(__var, __timer, __reps) \
    __var = __timer->cpu*0.001/__reps;

#define TIMEIT_REPEAT1(__timer, __reps) \
    do \
    { \
        slong __timeit_k; \
        __reps = 1; \
        while (1) \
        { \
            timeit_start(__timer); \
            for (__timeit_k = 0; __timeit_k < __reps; __timeit_k++) \
            {

#define TIMEIT_END_REPEAT1(__timer, __reps) \
            } \
            timeit_stop(__timer); \
            if (__timer->cpu >= 30) \
                break; \
            __reps *= 10; \
        } \
    } while (0);

#define TIMEIT_START1 \
    do { \
        timeit_t __timer; slong __reps; \
        TIMEIT_REPEAT1(__timer, __reps)

#define TIMEIT_STOP1(__var) \
        TIMEIT_END_REPEAT1(__timer, __reps) \
        TIMEIT_PRINT1(__var, __timer, __reps) \
    } while (0);

slong precs[] = {64, 256, 1024, 3333, 33333, 0};
slong ns[] = {10,20,50,100,200,500,1000,2000,5000,10000,100000,1000000};

int main()
{
    slong n, i, j, k, prec, rep, step;
    double t1, t2, t3, t4, t5;
    arb_t s, x, w, t, r;
    arb_ptr xs, ws;
    arb_init(x);
    arb_init(w);
    arb_init(t);
    arb_init(r);
    arb_init(t);
    arb_init(s);

    acb_t z;
    acb_init(z);

    prec = 3408;
    for (i = 1; i <= 10; i++)
    {
        n = 3 << (i + 1);
        printf("%ld\n", n);

        xs = _arb_vec_init(n);
        ws = _arb_vec_init(n);

        TIMEIT_START
        for (k = 0; k < n / 2; k++)
            arb_hypgeom_legendre_p_ui_root(xs + k, ws + k, n, k, prec);
        TIMEIT_STOP

        for (k = n / 2; k < n; k++)
        {
            arb_neg(xs + k, xs + n - 1 - k);
            arb_set(ws + k, ws + n - 1 - k);
        }

        TIMEIT_START
        arb_zero(s);
        for (k = 0; k < n; k++)
        {
#if 0
            arb_add_ui(t, xs + k, 2, prec);
            arb_log(t, t, prec);
            arb_addmul(s, t, ws + k, prec);
#endif

#if 0
            arb_set_ui(acb_realref(z), 1);
            arb_mul_ui(acb_imagref(z), xs + k, 1, prec);
            acb_gamma(z, z, prec);
            arb_set(t, acb_realref(z));
            arb_addmul(s, t, ws + k, prec);

#endif

#if 1
            arb_mul_ui(t, xs + k, 10, prec);
            arb_hypgeom_airy(t, NULL, NULL, NULL, t, prec);
            arb_addmul(s, t, ws + k, prec);
#endif
        }
        TIMEIT_STOP

#if 0
        arb_log_ui(r, 3, prec);
        arb_mul_ui(r, r, 3, prec);
        arb_sub_ui(r, r, 2, prec);
#endif

#if 0
        arb_set_str(r, "1.57239266949806559075198297278478209135231172387993819069313546393443758953396973642297613604098814617137347054301950568564423437784143953198884437745463958850066838746298693743121116367225999188039745778437224356721527775098778780058196835359347901900868493176978966522723290073721765442260140089887879310539559950005889031808529424106615471409357523859689924174656147994835184657673238252910791012308069100786753213003217184671360430728995240063246077713231739446079241460198006838693324424960823832455701711152398258931166025007655286284356510603191038504006607212832774762593165004467470061268686736145526122777106666140133340996660135637161281616253060971586067494983744673906624698662874339216422262555653389520600023731245476749363887592211814621370371108413066160817506304770001995416228554114898162596946474284126931797360268771390029347960491211725589036254309986007171293083829916490396339046076547249721182317246635532646722118439474298919066925642617797525030972148714872870635023412791856194084485749502528315843639197700686261344676540411537163287340007610732800972884902590813135765869419114842682402323743664713107217253840523193880617104648177800811523870470975724255071784420478657063", prec);
#endif

#if 1
        arb_set_str(r, "0.10990317364333819333679412354778428474599847954105073385203878829379756653063638802899923350903098290084544000716092300224638014883498907909937547546057918360586542802015929771412842672793896412651154877388183163187749381201110304596029598068840079719994820587716417997769733215720194885772488875417932147835404272225778303818962923684370056841150538028772951375462244933214536295145531084365176443776486676351535997642529430579371872216283291598287525272042617476846433468682148951903566637658293851754737801011119019162275127454432182631765432267748173425851255992132423475567929072633263742734845842276918217159364133165355168570493428995229209085852419126876888871376665686942983220517100227411698708452503609940208631578244381606423328810877071411807925895716108143834636019373295465493569894268921520321195392834866522818779193384033150976179363433593935378938110641049936027823447608014746852226229433683825915803439741613598966991065510411914080495661160745803784953047805643683571543228900105332339572465588026252979000187988555465644352567604295538355301635939443229838264248794469171429981231388851167778351752122785408885847085519220934635677105282815636327923794647435105886331453250882348880611176955516100177606258423516911454806476403256001290371362487214192705664950702887631953984962346391844450983915682320636646379664651210824968646372509052689791599418031105995623107445261096849420676909604518164738242363482685184669375156867170110478007201914411897820640561291858825709444063", prec);
#endif

        arb_printn(s, 10, ARB_STR_NO_RADIUS);
        printf("\n");
        arb_sub(x, s, r, prec);
        arb_abs(x, x);
        arb_printn(x, 10, ARB_STR_NO_RADIUS);
        printf("\n");

        arb_set(r, s);

        _arb_vec_clear(xs, n);
        _arb_vec_clear(ws, n);

        printf("\n");
    }

    return 0;




    for (i = 0; (n = ns[i]) != 0; i++)
    {
        printf("%ld  & ", n);

        for (j = 0; (prec = precs[j]) != 0; j++)
        {
            step =  FLINT_MAX(1, n / 1000);

            slong fail = 0;
            slong acc = 1000;

            t1 = 1e300;
            for (rep = 0; rep < 10; rep++)
            {
                fail = 0;
                TIMEIT_START1
                for (k = 0; k < n / 2; k += step)
                {
                    arb_hypgeom_legendre_p_ui_root(x, w, n, k, prec);
                    //acc = FLINT_MIN(acc, arb_rel_accuracy_bits(x));
                    //acc = FLINT_MIN(acc, arb_rel_accuracy_bits(w));
#if 0
                    slong pp = prec;
                    if (!arb_can_round_arf(x, 53, ARF_RND_NEAR) ||
                           !arb_can_round_arf(w, 53, ARF_RND_NEAR))
                    {
                        fail++;
                        pp += 10;
                        arb_hypgeom_legendre_p_ui_root(x, w, n, k, pp);
                    }
#endif
                }
                TIMEIT_STOP1(t2)
                t1 = FLINT_MIN(t1, t2);
                if (t1 > 1.0) break;
            }

            printf("%g  [FAIL %ld] &  ", t1 * step, fail);
            fflush(stdout);
        }
        printf("\\\\ \n");
    }
}

